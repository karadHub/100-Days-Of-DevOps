# Day 55: Kubernetes Sidecar Containers

## 🛠️ Task

We have a web server container running the nginx image. The access and error logs generated by the web server are not critical enough to be placed on a persistent volume. However, Nautilus developers need access to the last 24 hours of logs so that they can trace issues and bugs. Therefore, we need to ship the access and error logs for the web server to a log-aggregation service.

Following the separation of concerns principle, we implement the **Sidecar pattern** by deploying a second container that ships the error and access logs from nginx. Nginx does one thing, and it does it well—serving web pages. The second container also specializes in its task—shipping logs. Since containers are running on the same Pod, we can use a shared `emptyDir` volume to read and write logs.

### Requirements:

- Create a pod named `webserver`
- Create an `emptyDir` volume named `shared-logs`
- **Container 1 (nginx-container)**:
  - Image: `nginx:latest`
  - Mount `shared-logs` at `/var/log/nginx`
- **Container 2 (sidecar-container)**:
  - Image: `ubuntu:latest`
  - Command: `sh -c "while true; do cat /var/log/nginx/access.log /var/log/nginx/error.log; sleep 30; done"`
  - Mount `shared-logs` at `/var/log/nginx`

---

## ✅ Solution

### 📄 `webserver.yaml`

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: webserver
spec:
  volumes:
    - name: shared-logs
      emptyDir: {}
  containers:
    - name: nginx-container
      image: nginx:latest
      volumeMounts:
        - name: shared-logs
          mountPath: /var/log/nginx
    - name: sidecar-container
      image: ubuntu:latest
      command:
        [
          "sh",
          "-c",
          "while true; do cat /var/log/nginx/access.log /var/log/nginx/error.log; sleep 30; done",
        ]
      volumeMounts:
        - name: shared-logs
          mountPath: /var/log/nginx
```

---

## 🚀 Deployment & Verification

### 1) Apply the Pod

```bash
kubectl apply -f webserver.yaml
```

### 2) Verify Pod and Containers

```bash
kubectl get pod webserver
kubectl describe pod webserver
```

Expected output:

```
NAME        READY   STATUS    RESTARTS   AGE
webserver   2/2     Running   0          30s
```

### 3) Check Nginx Container

```bash
kubectl exec -it webserver -c nginx-container -- /bin/bash
# Inside the container:
ls -la /var/log/nginx/
cat /var/log/nginx/access.log
exit
```

### 4) Check Sidecar Container Logs

The sidecar container continuously outputs nginx logs every 30 seconds:

```bash
kubectl logs -f webserver -c sidecar-container
```

### 5) Generate Some Traffic to See Logs

```bash
# Get pod IP
kubectl get pod webserver -o wide

# From another pod or jump host, generate traffic:
kubectl run curl-test --image=curlimages/curl --rm -it --restart=Never -- curl http://<POD_IP>

# Or exec into nginx container and curl localhost:
kubectl exec webserver -c nginx-container -- curl http://localhost
```

### 6) Verify Logs are Being Shipped

```bash
# Check sidecar logs again to see the access log entry:
kubectl logs --tail=50 webserver -c sidecar-container
```

---

## 🧠 Understanding the Sidecar Pattern

### What is a Sidecar Container?

A **sidecar container** is a secondary container that runs alongside the main application container in the same Pod. It extends and enhances the functionality of the main container without changing its code.

### Key Characteristics:

| Aspect                    | Description                                             |
| ------------------------- | ------------------------------------------------------- |
| **Shared Lifecycle**      | Sidecar starts, runs, and stops with the main container |
| **Shared Resources**      | Share network namespace, IPC, and can share volumes     |
| **Single Responsibility** | Each container has one specific job                     |
| **Loose Coupling**        | Main app doesn't need to know about the sidecar         |

### Common Sidecar Use Cases:

1. **Log Shipping** (this task) - Ship logs to centralized logging
2. **Service Mesh** - Envoy proxy for traffic management (Istio)
3. **Monitoring** - Collect and export metrics
4. **Configuration** - Dynamic config updates
5. **Security** - TLS termination, authentication

---

## 🔍 How This Solution Works

```
┌─────────────────────────────────────────────────┐
│                 Pod: webserver                   │
│                                                  │
│  ┌────────────────────┐  ┌──────────────────┐   │
│  │ nginx-container    │  │ sidecar-container│   │
│  │                    │  │                  │   │
│  │  nginx:latest      │  │  ubuntu:latest   │   │
│  │                    │  │                  │   │
│  │  Serves web pages  │  │  Reads & ships   │   │
│  │  Writes logs to:   │  │  logs from:      │   │
│  │  /var/log/nginx/   │  │  /var/log/nginx/ │   │
│  └─────────┬──────────┘  └────────┬─────────┘   │
│            │                      │             │
│            └──────┬───────────────┘             │
│                   │                             │
│            ┌──────▼─────────┐                   │
│            │  shared-logs   │                   │
│            │   (emptyDir)   │                   │
│            └────────────────┘                   │
└─────────────────────────────────────────────────┘
```

1. **Nginx writes logs** → `/var/log/nginx/` (shared volume)
2. **Sidecar reads logs** → from the same `/var/log/nginx/`
3. **Sidecar ships logs** → outputs to stdout (every 30 seconds)
4. **Logs captured** → `kubectl logs` retrieves sidecar output

---

## 🔧 Additional Commands

```bash
# Check both container statuses
kubectl get pod webserver -o jsonpath='{.status.containerStatuses[*].name}{"\n"}{.status.containerStatuses[*].ready}'

# View volume mounts for both containers
kubectl get pod webserver -o jsonpath='{.spec.containers[*].volumeMounts}'

# Stream logs from both containers simultaneously (in separate terminals)
kubectl logs -f webserver -c nginx-container
kubectl logs -f webserver -c sidecar-container

# Exec into sidecar to debug
kubectl exec -it webserver -c sidecar-container -- /bin/bash

# Check if log files exist in sidecar
kubectl exec webserver -c sidecar-container -- ls -la /var/log/nginx/

# Delete the pod
kubectl delete pod webserver
```

---

## 💡 Production Considerations

### Real-World Log Shipping

In production, instead of `cat` every 30 seconds, you'd typically use:

- **Fluentd** or **Fluent Bit** - Log forwarders
- **Filebeat** - Elastic Stack log shipper
- **Logstash** - Log processing pipeline
- **Promtail** - Loki log collector

### Example with Fluentd:

```yaml
- name: fluentd-sidecar
  image: fluent/fluentd:latest
  volumeMounts:
    - name: shared-logs
      mountPath: /var/log/nginx
    - name: fluentd-config
      mountPath: /fluentd/etc
```

### Alternative: Kubernetes Native Logging

For simpler setups, you can configure nginx to log to stdout/stderr instead:

```yaml
- name: nginx-container
  image: nginx:latest
  command:
    [
      "/bin/sh",
      "-c",
      "ln -sf /dev/stdout /var/log/nginx/access.log && ln -sf /dev/stderr /var/log/nginx/error.log && nginx -g 'daemon off;'",
    ]
```

Then use `kubectl logs webserver -c nginx-container` directly without a sidecar.

---

## 🎯 Key Takeaways

✅ Sidecar pattern follows separation of concerns
✅ emptyDir volumes enable container communication
✅ Each container specializes in one task
✅ Sidecars are a fundamental Kubernetes pattern
✅ Used extensively in service meshes and observability
